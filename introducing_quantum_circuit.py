# -*- coding: utf-8 -*-
"""introducing_quantum_circuit.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/15zk0lppGwCI_govr2WejXM92uvkZOqp9

#Installing python packages:
"""

!pip install qiskit
!pip install numpy
!pip install pandas
!pip install matplotlib
!pip install pylatexenc

"""#Importing all python packages:"""

# Commented out IPython magic to ensure Python compatibility.
from qiskit import *
from pylatexenc import *
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from qiskit_aer import AerSimulator
# %matplotlib inline

"""#Bit flip circuit:"""

qc_circuit1=QuantumCircuit(1,1)
qc_circuit1.x([0])
qc_circuit1.measure([0],[0])
qc_circuit1.draw(output='mpl')

simulator = AerSimulator()
compiled_qc_circuit1 = transpile(qc_circuit1, simulator)
job1 = simulator.run(compiled_qc_circuit1, shots=1000)
result1 = job1.result()
counts1 = result1.get_counts(compiled_qc_circuit1)
print("\nTotal count for 0 and 1 are:", counts1)

"""#Phase flip circuit:"""

qc_circuit2=QuantumCircuit(1,1)
qc_circuit2.z([0])
qc_circuit2.measure([0],[0])
qc_circuit2.draw(output='mpl')

compiled_qc_circuit2 = transpile(qc_circuit2, simulator)
job2 = simulator.run(compiled_qc_circuit2, shots=1000)
result2 = job2.result()
counts2 = result2.get_counts(compiled_qc_circuit2)
print("\nTotal count for 00 and 11 are:", counts2)

qc_circuit3=QuantumCircuit(1,1)
qc_circuit3.y([0])
qc_circuit3.measure([0],[0])
qc_circuit3.draw(output='mpl')

compiled_qc_circuit3 = transpile(qc_circuit3, simulator)
job3 = simulator.run(compiled_qc_circuit3, shots=1000)
result3 = job3.result()
counts3 = result3.get_counts(compiled_qc_circuit3)
print("\nTotal count for 00 and 11 are:", counts3)

"""#Hadamard Gate:"""

qc_circuit4=QuantumCircuit(1,1)
qc_circuit4.h([0])
qc_circuit4.measure([0],[0])
qc_circuit4.draw(output='mpl')

compiled_qc_circuit4 = transpile(qc_circuit4, simulator)
job4 = simulator.run(compiled_qc_circuit4, shots=1000)
result4 = job4.result()
counts4 = result4.get_counts(compiled_qc_circuit4)
print("\nTotal count for 0 and 1 are:", counts4)

"""#Rotational Gate:"""

qc_circuit5=QuantumCircuit(1,1)
theta=np.pi/2
qc_circuit5.rx(theta, 0)
qc_circuit5.measure([0],[0])
qc_circuit5.draw(output='mpl')

compiled_qc_circuit5 = transpile(qc_circuit5, simulator)
job5 = simulator.run(compiled_qc_circuit5, shots=1000)
result5 = job5.result()
counts5 = result5.get_counts(compiled_qc_circuit5)
print("\nTotal count for 0 and 1 are:", counts5)

"""#2-bit Quantum Circuit:"""

qc_circuit6=QuantumCircuit(2,2)
qc_circuit6.cx([0], [1])
qc_circuit6.measure([0, 1],[0, 1])
qc_circuit6.draw(output='mpl')

compiled_qc_circuit6 = transpile(qc_circuit6, simulator)
job6 = simulator.run(compiled_qc_circuit6, shots=1000)
result6 = job6.result()
counts6 = result6.get_counts(compiled_qc_circuit6)
print("\nTotal count for 00 and 11 are:", counts6)

"""#3-bit Qunatum Circuit:"""

qc_circuit7=QuantumCircuit(3,3)
qc_circuit7.x([0,1])
qc_circuit7.ccx([0], [1], [2])
qc_circuit7.measure([0, 1, 2],[0, 1, 2])
qc_circuit7.draw(output='mpl')

compiled_qc_circuit7 = transpile(qc_circuit7, simulator)
job7 = simulator.run(compiled_qc_circuit7, shots=1000)
result7 = job7.result()
counts7 = result7.get_counts(compiled_qc_circuit7)
print("\nTotal count for 000 and 111 are:", counts7)

"""#Bit Flip circuit is an example of classical NOT gate. Like NOT Gate, bit flip circuit flips the bit from 0 to 1 and 1 to 0.
### NOT Gate
As was mentioned before, an X gate can be considered a NOT gate. The truth table for a NOT gate looks like this:


|input|output|
|--|--|
|0|1|
|1|0|

Simulation of this circuit:
https://youtu.be/mkYQDbm3m3g
"""

not_gate=QuantumCircuit(1,1)
not_gate.x([0])
not_gate.measure([0],[0])
not_gate.draw(output='mpl')

"""#AND Gate:
### AND Gate
The truth table for an AND Gate looks like this:

|A (input)|B (input)|output|
|--|--|--|
|0|0|0|
|0|1|0|
|1|0|0|
|1|1|1|

Simulation of this circuit: https://youtu.be/f1Koc-ONsW8
"""

and_gate=QuantumCircuit(3,1)
and_gate.ccx([0], [1], [2])
and_gate.measure([2],[0])
and_gate.draw(output='mpl')

"""##OR Gate:

|A(input)|B(input)|output|
|--|--|--|
|0|0|0|
|0|1|1|
|1|0|1|
|1|1|1|

Simulation of this circuit: https://youtu.be/LzpnjLHu5ws
"""

or_gate=QuantumCircuit(3,1)
or_gate.cx([1], [2])
or_gate.cx([0], [2])
or_gate.ccx([0], [1], [2])
or_gate.measure([2],[0])
or_gate.draw(output='mpl')

"""#NAND Gate:

A NAND gate can be made by applying a NOT gate after applying an AND gate.

|A(input)|B(input)|output|
|--|--|--|
|0|0|1|
|0|1|1|
|1|0|1|
|1|1|0|

Simulation of this circuit: https://youtu.be/TwcMI2VadVw
"""

nand_gate=QuantumCircuit(3,1)
nand_gate.ccx([0], [1], [2])
nand_gate.x([2])
nand_gate.measure([2], [0])
nand_gate.draw(output='mpl')

"""#NOR Gate:

|A(input)|B(input)|output|
|--|--|--|
|0|0|1|
|0|1|0|
|1|0|0|
|1|1|0|

Simulation of this circuit: https://youtu.be/99zaMwhJMCM
"""

nor_gate= QuantumCircuit(3,1)
nor_gate.cx([1], [2])
nor_gate.cx([0], [2])
nor_gate.ccx([0], [1], [2])
nor_gate.x([2])
nor_gate.measure([2], [0])
nor_gate.draw(output='mpl')

"""### XOR Gate
|A(input)|B(input)|output|
|--|--|--|
|0|0|0|
|0|1|1|
|1|0|1|
|1|1|0|

Simulation of this circuit: https://youtu.be/Qb1jzMOBwkM
"""

xor_gate = QuantumCircuit(3,1)
xor_gate.cx([1], [2])
xor_gate.cx([0], [2])
xor_gate.measure([2], [0])
xor_gate.draw(output='mpl')

"""#Half-Adder circuit:
The half adder is used to add together the two least significant digits in a binary sum.
It has two single binary inputs, called A and B, and two outputs C (carry out) and S (sum).
The output C will be used as an input to the Full Adder, which will be explained later, for obtaining the value in the higher digit.

Half adders can be described with the truth table shown below.

|A (input)|B (input)|S (sum)|C (carry out)|
|-----------|------------|------------|------------|
|0|0|0|0|
|0|1|1|0|
|1|0|1|0|
|1|1|0|1|

From the truth table, you should notice that the carry output, C, is a result of operating an AND gate against A and B, where the output S is a result of operating an XOR against A and B.
As we have already created the AND and XOR gates, we can combine these gates and create a half adder as follows.

https://youtu.be/uu7hHTcKmI8

#Problem Statement:

Build a quantum half-adder circuit like classical one above. You can take as much qubit and quantum circuit as you want to solve this problem.

Instructions to follow (optional):

1. First read the question and the example of the classical circuit. Then think, what you need to develop based on what you have
2. Evaluate your understanding of the quantum circuit by studying the examples
3. Plan your circuit development strategy. [Hint: You can think of replacing classical gate with quantum ones]
4. Apply your plan and monitor your circuit development process. Keep checking if you are moving towards right direction or right answers. If not, adjust your circuit development plan.
5. If you get wrong answer, ask yourself question: why it is not right?
If you get the correct answer, give yourself 1-2 minutes to evaluate the strength and weakness of your development process.

The code to solve this problem is given below. You just need to decide how many qubit, you need to take and what gate you want to use. 

q = QuantumRegister(___)
c = ClassicalRegister(___)
half_adder = QuantumCircuit(q,c)


half_adder.__(__)
half_adder.__ (___, ___)
qc.barrier()

half_adder.___(___)
qc.barrier()


qc.measure(____)

qc.measure(____)
"""

